# This file was automatically generated by SWIG (http://www.swig.org).
# Version 1.3.36
#
# Don't modify this file, modify the SWIG interface instead.

"""
An interface to LDB, a LDAP-like API that can either to talk an embedded database (TDB-based) or a standards-compliant LDAP server.
"""

import _ldb
import new
new_instancemethod = new.instancemethod
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'PySwigObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static) or hasattr(self,name):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError,name

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

import types
try:
    _object = types.ObjectType
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0
del types


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


SCOPE_DEFAULT = _ldb.SCOPE_DEFAULT
SCOPE_BASE = _ldb.SCOPE_BASE
SCOPE_ONELEVEL = _ldb.SCOPE_ONELEVEL
SCOPE_SUBTREE = _ldb.SCOPE_SUBTREE
CHANGETYPE_NONE = _ldb.CHANGETYPE_NONE
CHANGETYPE_ADD = _ldb.CHANGETYPE_ADD
CHANGETYPE_DELETE = _ldb.CHANGETYPE_DELETE
CHANGETYPE_MODIFY = _ldb.CHANGETYPE_MODIFY
ldb_val_to_py_object = _ldb.ldb_val_to_py_object
class Dn(object):
    """A LDB distinguished name."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): 
        """
        S.__init__(ldb, string)
        Create a new DN.
        """
        _ldb.Dn_swiginit(self,_ldb.new_Dn(*args, **kwargs))
    __swig_destroy__ = _ldb.delete_Dn
    def validate(*args, **kwargs):
        """
        S.validate() -> bool
        Validate DN is correct.
        """
        return _ldb.Dn_validate(*args, **kwargs)

    def parent(*args, **kwargs):
        """
        S.parent() -> dn
        Get the parent for this DN.
        """
        return _ldb.Dn_parent(*args, **kwargs)

    def is_special(*args, **kwargs):
        """
        S.is_special() -> bool
        Check whether this is a special LDB DN.
        """
        return _ldb.Dn_is_special(*args, **kwargs)

    def is_null(*args, **kwargs):
        """
        S.is_null() -> bool
        Check whether this is a null DN.
        """
        return _ldb.Dn_is_null(*args, **kwargs)

    def add_child(*args, **kwargs):
        """
        S.add_child(dn) -> None
        Add a child DN to this DN.
        """
        return _ldb.Dn_add_child(*args, **kwargs)

    def add_base(*args, **kwargs):
        """
        S.add_base(dn) -> None
        Add a base DN to this DN.
        """
        return _ldb.Dn_add_base(*args, **kwargs)

    def canonical_str(*args, **kwargs):
        """
        S.canonical_str() -> string
        Canonical version of this DN (like a posix path).
        """
        return _ldb.Dn_canonical_str(*args, **kwargs)

    def canonical_ex_str(*args, **kwargs):
        """
        S.canonical_ex_str() -> string
        Canonical version of this DN (like a posix path, with terminating newline).
        """
        return _ldb.Dn_canonical_ex_str(*args, **kwargs)

    def __eq__(self, other):
        if isinstance(other, self.__class__):
            return self.__cmp__(other) == 0
        if isinstance(other, str):
            return str(self) == other
        return False

Dn.validate = new_instancemethod(_ldb.Dn_validate,None,Dn)
Dn.get_casefold = new_instancemethod(_ldb.Dn_get_casefold,None,Dn)
Dn.__str__ = new_instancemethod(_ldb.Dn___str__,None,Dn)
Dn.parent = new_instancemethod(_ldb.Dn_parent,None,Dn)
Dn.__cmp__ = new_instancemethod(_ldb.Dn___cmp__,None,Dn)
Dn.is_valid = new_instancemethod(_ldb.Dn_is_valid,None,Dn)
Dn.is_special = new_instancemethod(_ldb.Dn_is_special,None,Dn)
Dn.is_null = new_instancemethod(_ldb.Dn_is_null,None,Dn)
Dn.check_special = new_instancemethod(_ldb.Dn_check_special,None,Dn)
Dn.__len__ = new_instancemethod(_ldb.Dn___len__,None,Dn)
Dn.add_child = new_instancemethod(_ldb.Dn_add_child,None,Dn)
Dn.add_base = new_instancemethod(_ldb.Dn_add_base,None,Dn)
Dn.canonical_str = new_instancemethod(_ldb.Dn_canonical_str,None,Dn)
Dn.canonical_ex_str = new_instancemethod(_ldb.Dn_canonical_ex_str,None,Dn)
Dn.__repr__ = new_instancemethod(_ldb.Dn___repr__,None,Dn)
Dn.__add__ = new_instancemethod(_ldb.Dn___add__,None,Dn)
Dn_swigregister = _ldb.Dn_swigregister
Dn_swigregister(Dn)

class MessageElement(object):
    """Message element."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """Message element."""
        _ldb.MessageElement_swiginit(self,_ldb.new_MessageElement(*args, **kwargs))
    __swig_destroy__ = _ldb.delete_MessageElement
    def __getitem__(self, i):
        ret = self.get(i)
        if ret is None:
            raise KeyError("no such value")
        return ret

    def __repr__(self):
        return "MessageElement([%s])" % (",".join(repr(x) for x in self.__set__()))

    def __eq__(self, other):
        if (len(self) == 1 and self.get(0) == other):
            return True
        if isinstance(other, self.__class__):
            return self.__cmp__(other) == 0
        o = iter(other)
        for i in range(len(self)):
            if self.get(i) != o.next():
                return False
        return True

MessageElement.__cmp__ = new_instancemethod(_ldb.MessageElement___cmp__,None,MessageElement)
MessageElement.__iter__ = new_instancemethod(_ldb.MessageElement___iter__,None,MessageElement)
MessageElement.__set__ = new_instancemethod(_ldb.MessageElement___set__,None,MessageElement)
MessageElement.__len__ = new_instancemethod(_ldb.MessageElement___len__,None,MessageElement)
MessageElement.get = new_instancemethod(_ldb.MessageElement_get,None,MessageElement)
MessageElement_swigregister = _ldb.MessageElement_swigregister
MessageElement_swigregister(MessageElement)

ldb_msg_list_elements = _ldb.ldb_msg_list_elements
class Message(object):
    """Message."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    dn = _swig_property(_ldb.Message_dn_get, _ldb.Message_dn_set)
    def __init__(self, *args, **kwargs): 
        _ldb.Message_swiginit(self,_ldb.new_Message(*args, **kwargs))
    __swig_destroy__ = _ldb.delete_Message
    def get(self, key, default=None):
        if key == "dn":
            return self.dn
        return self.find_element(key)

    def __getitem__(self, key):
        ret = self.get(key, None)
        if ret is None:
            raise KeyError("No such element")
        return ret

    def iteritems(self):
        for k in self.keys():
            yield k, self[k]

    def items(self):
        return list(self.iteritems())

    def __repr__(self):
        return "Message(%s)" % repr(dict(self.iteritems()))

Message.find_element = new_instancemethod(_ldb.Message_find_element,None,Message)
Message.__setitem__ = new_instancemethod(_ldb.Message___setitem__,None,Message)
Message.__len__ = new_instancemethod(_ldb.Message___len__,None,Message)
Message.keys = new_instancemethod(_ldb.Message_keys,None,Message)
Message.__iter__ = new_instancemethod(_ldb.Message___iter__,None,Message)
Message.__delitem__ = new_instancemethod(_ldb.Message___delitem__,None,Message)
Message_swigregister = _ldb.Message_swigregister
Message_swigregister(Message)

ldb_ldif_to_pyobject = _ldb.ldb_ldif_to_pyobject
LdbError = _ldb.LdbError

LDB_ERR_OPERATIONS_ERROR = _ldb.LDB_ERR_OPERATIONS_ERROR
LDB_ERR_PROTOCOL_ERROR = _ldb.LDB_ERR_PROTOCOL_ERROR
LDB_ERR_TIME_LIMIT_EXCEEDED = _ldb.LDB_ERR_TIME_LIMIT_EXCEEDED
LDB_ERR_SIZE_LIMIT_EXCEEDED = _ldb.LDB_ERR_SIZE_LIMIT_EXCEEDED
LDB_ERR_COMPARE_FALSE = _ldb.LDB_ERR_COMPARE_FALSE
LDB_ERR_COMPARE_TRUE = _ldb.LDB_ERR_COMPARE_TRUE
LDB_ERR_AUTH_METHOD_NOT_SUPPORTED = _ldb.LDB_ERR_AUTH_METHOD_NOT_SUPPORTED
LDB_ERR_STRONG_AUTH_REQUIRED = _ldb.LDB_ERR_STRONG_AUTH_REQUIRED
LDB_ERR_REFERRAL = _ldb.LDB_ERR_REFERRAL
LDB_ERR_ADMIN_LIMIT_EXCEEDED = _ldb.LDB_ERR_ADMIN_LIMIT_EXCEEDED
LDB_ERR_UNSUPPORTED_CRITICAL_EXTENSION = _ldb.LDB_ERR_UNSUPPORTED_CRITICAL_EXTENSION
LDB_ERR_CONFIDENTIALITY_REQUIRED = _ldb.LDB_ERR_CONFIDENTIALITY_REQUIRED
LDB_ERR_SASL_BIND_IN_PROGRESS = _ldb.LDB_ERR_SASL_BIND_IN_PROGRESS
LDB_ERR_NO_SUCH_ATTRIBUTE = _ldb.LDB_ERR_NO_SUCH_ATTRIBUTE
LDB_ERR_UNDEFINED_ATTRIBUTE_TYPE = _ldb.LDB_ERR_UNDEFINED_ATTRIBUTE_TYPE
LDB_ERR_INAPPROPRIATE_MATCHING = _ldb.LDB_ERR_INAPPROPRIATE_MATCHING
LDB_ERR_CONSTRAINT_VIOLATION = _ldb.LDB_ERR_CONSTRAINT_VIOLATION
LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS = _ldb.LDB_ERR_ATTRIBUTE_OR_VALUE_EXISTS
LDB_ERR_INVALID_ATTRIBUTE_SYNTAX = _ldb.LDB_ERR_INVALID_ATTRIBUTE_SYNTAX
LDB_ERR_NO_SUCH_OBJECT = _ldb.LDB_ERR_NO_SUCH_OBJECT
LDB_ERR_ALIAS_PROBLEM = _ldb.LDB_ERR_ALIAS_PROBLEM
LDB_ERR_INVALID_DN_SYNTAX = _ldb.LDB_ERR_INVALID_DN_SYNTAX
LDB_ERR_ALIAS_DEREFERENCING_PROBLEM = _ldb.LDB_ERR_ALIAS_DEREFERENCING_PROBLEM
LDB_ERR_INAPPROPRIATE_AUTHENTICATION = _ldb.LDB_ERR_INAPPROPRIATE_AUTHENTICATION
LDB_ERR_INVALID_CREDENTIALS = _ldb.LDB_ERR_INVALID_CREDENTIALS
LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS = _ldb.LDB_ERR_INSUFFICIENT_ACCESS_RIGHTS
LDB_ERR_BUSY = _ldb.LDB_ERR_BUSY
LDB_ERR_UNAVAILABLE = _ldb.LDB_ERR_UNAVAILABLE
LDB_ERR_UNWILLING_TO_PERFORM = _ldb.LDB_ERR_UNWILLING_TO_PERFORM
LDB_ERR_LOOP_DETECT = _ldb.LDB_ERR_LOOP_DETECT
LDB_ERR_NAMING_VIOLATION = _ldb.LDB_ERR_NAMING_VIOLATION
LDB_ERR_OBJECT_CLASS_VIOLATION = _ldb.LDB_ERR_OBJECT_CLASS_VIOLATION
LDB_ERR_NOT_ALLOWED_ON_NON_LEAF = _ldb.LDB_ERR_NOT_ALLOWED_ON_NON_LEAF
LDB_ERR_NOT_ALLOWED_ON_RDN = _ldb.LDB_ERR_NOT_ALLOWED_ON_RDN
LDB_ERR_ENTRY_ALREADY_EXISTS = _ldb.LDB_ERR_ENTRY_ALREADY_EXISTS
LDB_ERR_OBJECT_CLASS_MODS_PROHIBITED = _ldb.LDB_ERR_OBJECT_CLASS_MODS_PROHIBITED
LDB_ERR_AFFECTS_MULTIPLE_DSAS = _ldb.LDB_ERR_AFFECTS_MULTIPLE_DSAS
LDB_ERR_OTHER = _ldb.LDB_ERR_OTHER
class Ldb(object):
    """Connection to a LDB database."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    firstmodule = _swig_property(_ldb.Ldb_firstmodule_get, _ldb.Ldb_firstmodule_set)
    def itermodules(self):
        m = self.firstmodule
        while m is not None:
            yield m
            m = m.next

    def modules(self):
        return list(self.itermodules())

    def __init__(self, *args, **kwargs): 
        _ldb.Ldb_swiginit(self,_ldb.new_Ldb(*args, **kwargs))
    def connect(*args, **kwargs):
        """
        S.connect(url,flags=0,options=None) -> None
        Connect to a LDB URL.
        """
        return _ldb.Ldb_connect(*args, **kwargs)

    __swig_destroy__ = _ldb.delete_Ldb
    def delete(*args, **kwargs):
        """
        S.delete(dn) -> None
        Remove an entry.
        """
        return _ldb.Ldb_delete(*args, **kwargs)

    def rename(*args, **kwargs):
        """
        S.rename(old_dn, new_dn) -> None
        Rename an entry.
        """
        return _ldb.Ldb_rename(*args, **kwargs)

    def add(*args, **kwargs):
        """
        S.add(message) -> None
        Add an entry.
        """
        return _ldb.Ldb_add(*args, **kwargs)

    def modify(*args, **kwargs):
        """
        S.modify(message) -> None
        Modify an entry.
        """
        return _ldb.Ldb_modify(*args, **kwargs)

    def set_create_perms(*args, **kwargs):
        """
        S.set_create_perms(mode) -> None
        Set mode to use when creating new LDB files.
        """
        return _ldb.Ldb_set_create_perms(*args, **kwargs)

    def set_modules_dir(*args, **kwargs):
        """
        S.set_modules_dir(path) -> None
        Set path LDB should search for modules
        """
        return _ldb.Ldb_set_modules_dir(*args, **kwargs)

    def set_debug(*args, **kwargs):
        """
        S.set_debug(callback) -> None
        Set callback for LDB debug messages.
        The callback should accept a debug level and debug text.
        """
        return _ldb.Ldb_set_debug(*args, **kwargs)

    def set_opaque(*args, **kwargs):
        """
        S.set_opaque(name, value) -> None
        Set an opaque value on this LDB connection. 
        :note: Passing incorrect values may cause crashes.
        """
        return _ldb.Ldb_set_opaque(*args, **kwargs)

    def get_opaque(*args, **kwargs):
        """
        S.get_opaque(name) -> value
        Get an opaque value set on this LDB connection. 
        :note: The returned value may not be useful in Python.
        """
        return _ldb.Ldb_get_opaque(*args, **kwargs)

    def transaction_start(*args, **kwargs):
        """
        S.transaction_start() -> None
        Start a new transaction.
        """
        return _ldb.Ldb_transaction_start(*args, **kwargs)

    def transaction_commit(*args, **kwargs):
        """
        S.transaction_commit() -> None
        Commit currently active transaction.
        """
        return _ldb.Ldb_transaction_commit(*args, **kwargs)

    def transaction_cancel(*args, **kwargs):
        """
        S.transaction_cancel() -> None
        Cancel currently active transaction.
        """
        return _ldb.Ldb_transaction_cancel(*args, **kwargs)

    def parse_ldif(*args, **kwargs):
        """
        S.parse_ldif(ldif) -> iter(messages)
        Parse a string formatted using LDIF.
        """
        return _ldb.Ldb_parse_ldif(*args, **kwargs)

    def __init__(self, url=None, flags=0, options=None):
        """Create a new LDB object.

        Will also connect to the specified URL if one was given.
        """
        _ldb.Ldb_swiginit(self,_ldb.new_Ldb())
        if url is not None:
            self.connect(url, flags, options)

    def search(self, base=None, scope=SCOPE_DEFAULT, expression=None, 
               attrs=None, controls=None):
        """Search in a database.

        :param base: Optional base DN to search
        :param scope: Search scope (SCOPE_BASE, SCOPE_ONELEVEL or SCOPE_SUBTREE)
        :param expression: Optional search expression
        :param attrs: Attributes to return (defaults to all)
        :param controls: Optional list of controls
        :return: Iterator over Message objects
        """
        if not (attrs is None or isinstance(attrs, list)):
            raise TypeError("attributes not a list")
        parsed_controls = None
        if controls is not None:
            parsed_controls = self.parse_control_strings(controls)
        return self.search_ex(base, scope, expression, attrs, 
                              parsed_controls)

Ldb.connect = new_instancemethod(_ldb.Ldb_connect,None,Ldb)
Ldb.search_ex = new_instancemethod(_ldb.Ldb_search_ex,None,Ldb)
Ldb.delete = new_instancemethod(_ldb.Ldb_delete,None,Ldb)
Ldb.rename = new_instancemethod(_ldb.Ldb_rename,None,Ldb)
Ldb.parse_control_strings = new_instancemethod(_ldb.Ldb_parse_control_strings,None,Ldb)
Ldb.add = new_instancemethod(_ldb.Ldb_add,None,Ldb)
Ldb.modify = new_instancemethod(_ldb.Ldb_modify,None,Ldb)
Ldb.get_config_basedn = new_instancemethod(_ldb.Ldb_get_config_basedn,None,Ldb)
Ldb.get_root_basedn = new_instancemethod(_ldb.Ldb_get_root_basedn,None,Ldb)
Ldb.get_schema_basedn = new_instancemethod(_ldb.Ldb_get_schema_basedn,None,Ldb)
Ldb.get_default_basedn = new_instancemethod(_ldb.Ldb_get_default_basedn,None,Ldb)
Ldb.schema_format_value = new_instancemethod(_ldb.Ldb_schema_format_value,None,Ldb)
Ldb.errstring = new_instancemethod(_ldb.Ldb_errstring,None,Ldb)
Ldb.set_create_perms = new_instancemethod(_ldb.Ldb_set_create_perms,None,Ldb)
Ldb.set_modules_dir = new_instancemethod(_ldb.Ldb_set_modules_dir,None,Ldb)
Ldb.set_debug = new_instancemethod(_ldb.Ldb_set_debug,None,Ldb)
Ldb.set_opaque = new_instancemethod(_ldb.Ldb_set_opaque,None,Ldb)
Ldb.get_opaque = new_instancemethod(_ldb.Ldb_get_opaque,None,Ldb)
Ldb.transaction_start = new_instancemethod(_ldb.Ldb_transaction_start,None,Ldb)
Ldb.transaction_commit = new_instancemethod(_ldb.Ldb_transaction_commit,None,Ldb)
Ldb.transaction_cancel = new_instancemethod(_ldb.Ldb_transaction_cancel,None,Ldb)
Ldb.schema_attribute_remove = new_instancemethod(_ldb.Ldb_schema_attribute_remove,None,Ldb)
Ldb.schema_attribute_add = new_instancemethod(_ldb.Ldb_schema_attribute_add,None,Ldb)
Ldb.setup_wellknown_attributes = new_instancemethod(_ldb.Ldb_setup_wellknown_attributes,None,Ldb)
Ldb.__contains__ = new_instancemethod(_ldb.Ldb___contains__,None,Ldb)
Ldb.parse_ldif = new_instancemethod(_ldb.Ldb_parse_ldif,None,Ldb)
Ldb.__repr__ = new_instancemethod(_ldb.Ldb___repr__,None,Ldb)
Ldb_swigregister = _ldb.Ldb_swigregister
Ldb_swigregister(Ldb)


def valid_attr_name(*args, **kwargs):
  """
    S.valid_attr_name(name) -> bool
    Check whether the supplied name is a valid attribute name.
    """
  return _ldb.valid_attr_name(*args, **kwargs)

def timestring(*args, **kwargs):
  """
    S.timestring(int) -> string
    Generate a LDAP time string from a UNIX timestamp
    """
  return _ldb.timestring(*args, **kwargs)

def string_to_time(*args, **kwargs):
  """
    S.string_to_time(string) -> int
    Parse a LDAP time string into a UNIX timestamp.
    """
  return _ldb.string_to_time(*args, **kwargs)
class ldb_module(object):
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    prev = _swig_property(_ldb.ldb_module_prev_get, _ldb.ldb_module_prev_set)
    next = _swig_property(_ldb.ldb_module_next_get, _ldb.ldb_module_next_set)
    def __init__(self, *args, **kwargs): 
        _ldb.ldb_module_swiginit(self,_ldb.new_ldb_module(*args, **kwargs))
    __swig_destroy__ = _ldb.delete_ldb_module
ldb_module.__str__ = new_instancemethod(_ldb.ldb_module___str__,None,ldb_module)
ldb_module.__repr__ = new_instancemethod(_ldb.ldb_module___repr__,None,ldb_module)
ldb_module.search = new_instancemethod(_ldb.ldb_module_search,None,ldb_module)
ldb_module.add = new_instancemethod(_ldb.ldb_module_add,None,ldb_module)
ldb_module.modify = new_instancemethod(_ldb.ldb_module_modify,None,ldb_module)
ldb_module.delete = new_instancemethod(_ldb.ldb_module_delete,None,ldb_module)
ldb_module.rename = new_instancemethod(_ldb.ldb_module_rename,None,ldb_module)
ldb_module.start_transaction = new_instancemethod(_ldb.ldb_module_start_transaction,None,ldb_module)
ldb_module.end_transaction = new_instancemethod(_ldb.ldb_module_end_transaction,None,ldb_module)
ldb_module.del_transaction = new_instancemethod(_ldb.ldb_module_del_transaction,None,ldb_module)
ldb_module_swigregister = _ldb.ldb_module_swigregister
ldb_module_swigregister(ldb_module)


def register_module(*args, **kwargs):
  """
    S.register_module(module) -> None
    Register a LDB module.
    """
  return _ldb.register_module(*args, **kwargs)
__docformat__ = "restructuredText"
open = Ldb



